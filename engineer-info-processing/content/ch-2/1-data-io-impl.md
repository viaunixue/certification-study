# 데이터 입출력 구현

```
<< 2023 변경점 >>
1. 자료구조
	1. 스택
	2. 큐
	3. 리스트 등
2. 데이터 조작 프로시저 작성
3. 데이터 조작 프로시저 최적화
```
## 논리 데이터 저장소 확인

### 자료 구조 분류
| 구조 | 설명 | 종류 |
| ---- | ---- | ---- |
| 선형 구조 | 데이터 연속적으로 연결한 자료 구조 | 리스트, 스택, 큐, 데크 |
| 비선형 구조  | 데이터 비연속적으로 연결한 자료 구조 | 그래프, 트리 |

### 스택의 자료 삽입 삭제

#### 자료 삽입
```c
if Top = n Then      // 스택에 데이터 n개?
	Overflow         // 삽입할 공간 없으므로 overflow
Else {
	Top = Top + 1
	insert S(Top)    // 스택 포인터 Top 가리키는 곳에 데이터 삽입
}
```

#### 자료 삭제
```c
if Top = 0 Then      // 스택에 데이터 0개?
	Underflow        // 삭제할 데이터가 없으므로 underflow
Else {
	remove S(Top)    // 스택 포인터 Top 가리키는 곳에 데이터 삭제
	Top = Top - 1
}
```

### 스택 응용 분야
1. 인터럽트 처리
2. 함수 호출(재귀 호출 포함) : 함수 호출 시 현재 진행 중 명령어 주소 스택에 저장
3. 후위 표현 연산 : Postfix 계산 시 사용
4. 깊이 우선 탐색 : 내려갈 때마다 PUSH, 깊이 갈 곳 없을 경우 POP 한 노드와 인접한 노드 찾음

### 데크
큐 양쪽 끝에서 삽입과 삭제를 할 수 있는 자료 구조

### 트리 용어
| 용어 | 설명 |
| ---- | ---- |
| 루트 노드 |  |
| 단말 노드 |  |
| 레벨 |  |
| 조상 노드 |  |
| 자식 노드 |  |
| 부모 노드 |  |
| 형제 노드 |  |
| 깊이  | 루트 노드에서 특정 노드에 도달하기 위한 간선의 수 |
| 차수 | 특정 노드에 연결된 자식 노드의 수 |

### 트리 종류
| 종류 | 설명 |
| ---- | ---- |
| 이진 탐색 트리 | 차수 2 이하 노드로 구성되어 자식이 둘 이하로 구성된 트리 |
| AVL 트리 | 두 자식 서브 트리의 높이는 항상 최대 1만큼 차이가 나도록<br>스스로 균형을 잡는 이진 탐색 트리 |
| 2-3 트리 | 차수가 2 또는 3인 내부 노드를 갖는 탐색 트리<br>AVL 단점인 삽입,삭제 시 전체 트리 재구성 부분을 줄인 트리 |
| 레드-블랙 트리 | 각 노드는 빨강 또는 검정의 색상을 가지고 있으며,<br>색깔에 따른 규칙을 통해 스스로 균형을 잡는 이진 탐색 트리 |

###  그래프 유형
| 유형          |                                                   설명                                                    |
| ------------- |:---------------------------------------------------------------------------------------------------------:|
| 방향 그래프   |    정점을 연결하는 선에 방향이 있는 그래프<br>n개의 정점으로 구성된 방향 그래프 최대 간선 수<br>**n(n-1)**    |
| 무방향 그래프 | 정점을 연결하는 선에 방향이 없는 그래프<br>n개의 정점으로 구성된 무방향 그래프의 최대 간선 수<br>**n(n-1)/2** |
### 전위(Prefix) -> 후위(Postfix) 변환 과정

ex) `- / * A + B C D E`
1. `- / * A (+ B C) D E`
2. `- / (* A (+ B C)) D E`
3. `- (/ (* A (+ B C)) D) E`
4. `(- (/ (* A (+ B C)) D) E`
5. `(((A (B C +) *) D /) E -`

괄호를 모두 제거하면 Postfix 후위식은 `A B C + * D / E -` 입니다.

### 논리 데이터 저장소 구조
> 개속관 (개속 관계를 유지하자)

| 구조 | 설명 |
| ---- | ---- |
| 개체 |  |
| 속성 |  |
| 관계 |  |

## 물리 데이터 저장소 설계

### 물리 데이터 저장소 모델 변환
| 순서 | 변환 단계 | 수행 |
| ---- | ---- | ---- |
| 1 | 단위 개체를 테이블로 변환 |  |
| 2 | 속성을 컬럼으로 변환 |  |
| 3 | **UID 키를 기본 키로 변환** |  |
| 4 | **관계를 외래 키로 변환** |  |
| 5 | 컬럼 유형과 길이 정의 |  |
| 6 | 반 정규화 수행 |  |

### 반 정규화 수행 방법 상세
| 수행 방법 | 설명 |
| ---- | ---- |
| 테이블 통합 |  |
| 테이블 분할 |  |
| 중복 테이블 추가 | 통계 정보를 계산, 이력 정보를 추가, 테이블에 특정 부분만 사용하여 성능 향상<br>**집계 테이블 추가**, **진행 테이블 추가**, **특정 부분만 포함하는 테이블 추가**<br> |
| 컬럼 중복화 |  |

### 클러스터 설계 시 고려 사항
1. 검색 효율 높여주나 입력,수정,삭제 시 부하가 증가함을 고려
2. UNION, ORDER BY, DISTINCT, GROUP BY 빈번한 컬럼이면 검토 대상
3. 수정이 자주 발생하지 않는 컬럼 검토 대상
4. 처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링 고려
5. 조인이 많아 문제 발생되는 경우 다중 테이블 클러스터링 고려

### 파티션 종류
> 레해리컴라

| 종류 | 설명 |
| ---- | ---- |
| 범위 분할<br>(레인지 파티셔닝) | 분할 키값이 범위 내에 있는지 여부를 구분하는 분할 기법<br>지정한 열의 값을 기준으로 분할 |
| 해시 분할<br>(해시 파티셔닝) | 해시 함수 값에 따라 파티션에 포함할 지 여부<br>해시 함수에 따라 데이터 분할 |
| 목록 분할<br>(리스트 파티셔닝) | 값 목록에 파티션을 할당하고, 분할 키 값을 그 목록에 맞게 분할하는 기법<br>미리 정해진 그룹핑 기준에 따라 데이터 분할 |
| 조합 분할<br>(컴포지트 파티셔닝) | 범위 분할, 해시 분할, 목록 분할 중 2개 이상의 분할 기법을 결정하는 기법<br>범위 분할에 이후 해시 함수를 적용하여 재분할 |
| 라운드로빈 파티셔닝 | 라운드 로빈 분할로 회전하면서 새로운 행이 파티션에 할당하는 방식<br>파티션에 행의 고른 분포를 원할 때 사용 |

### 파티션 장점
> 성가백합 (성가대가 백합꽃을 들고 노래한다)

1. 성능 향상
2. 가용성 향상
3. 백업 가능
4. 경합 감소 : 디스크 스트라이핑(드라이브 병렬 사용)으로 입출력 성능 향상

### ORM (Object-Relational Mapping) 프레임워크
관계형 DB와 객체지향 프로그래밍 언어 간 호환되지 않는 데이터를 변환하는 프로그램

## 데이터 조작 프로시저 작성

### PL/SQL 장점
|       장점       | 설명 |
|:----------------:|:----:|
|  컴파일 불필요   |      |
|   모듈화 가능    |      |
| 절차적 언어 사용 |      |
|    에러 처리     |      |

### PL/SQL 활용한 저장형 객체 활용
> 프함패트 (프랑스 함정에 패트리어트 미사일 탑재)


|      구분       | 설명 |
|:---------------:|:----:|
| 저장된 프로시져 |      |
|   저장된 함수   |      |
|  저장된 패키지  |      |
|     트리거      |      |

### DBMS_OUPUT 패키지 기능
| 명령어 | 설명 |
| ---- | ---- |
| DBMS_OUTPUT.DISABLE | 메시지 버퍼내용 삭제 |
| DBMS_OUTPUT.ENABLE | 메시지 버퍼내용 할당 |
| DBMS_OUTPUT.PUT | 하나의 라인을 여러 번 걸쳐 저장 |
| DBMS_OUTPUT.LINE | PUT과 동일하나 버퍼에 저장되는 메시지의 <br>마지막 라인 끝에 EOL 문자를 추가 |
| DBMS_OUTPUT.GET_LINE | 한번 호출할 때마다 하나의 라인만을 읽어옴 |
| DBMS_OUTPUT.GET_LINES | 저장된 라인을 모두 읽어들임 |

## 데이터 조작 프로시저 최적화

### SQL 코드 인스펙션 대상
1. 미사용 변수
2. 미사용 서브 쿼리
3. Null 값 비교
4. 과거의 데이터 타입 사용

### SQL 성능 개선 절차
| 순서 |         절차         |                                                                              설명                                                                              |
|:----:|:--------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|  1   |  문제있는 SQL 식별   |                           애플리케이션 성능을 관리하거나 모니터링하기 위한 툴인 <br>APM(Application Performance Management) 등 활용                            |
|  2   | 옵티마이저 통계 확인 |                    옵티마이저는 개발자가 작성한 SQL을 가장 빠르고 효율적으로<br>수행할 최적의 처리 경로를 생성해주는 데이터베이스 핵심 모듈                    |
|  3   |     SQL문 재구성     |                                                   범위 아닌 특정 값 지정으로 범위를 줄여 처리속도 빠르게 함                                                    |
|  4   |     Index 재구성     | 성능에 중요한 액세스 경로를 고려하여 인덱스 생성<br>인덱스 추가 시 정상 처리되고 있던 다른 SQL에 심각한 영향을<br>줄 수 있으므로 주요 SQL질의 결과를 함께 검토 |
|  5   |  실행계획 유지관리   |                          DB 버전 업그레이드, 데이터 전환 등 시스템 환경의 <br>변경 사항 발생 시에도 실행 계획이 유지되고 있는지 관리                           |
