# 애플리케이션 설계

## 공통 모듈 설계
### 공통 모듈 원칙
> 정명 완일추

1. **정**확성
2. **명**확성
3. **완**전성
4. **일**관성
5. **추**적성

### 바람직한 모듈 설계 방안
1. 모듈의 독립성, 재사용성 높이기 위해 *결합도는 낮추고 응집도는 높인다.*
2. 모듈의 복잡성과 중복성은 줄이고 일관성은 유지한다
3. 모듈의 기능은 예측 가능해야 하며, *지나치게 제한적이어서는 안된다*.
4. 적당한 모듈 크기를 유지한다.
5. 설계에서 계층적 자료 조직이 제시되어야 한다.
6. 유지보수가 용이해야 하고 이식성을 고려해야 한다.
### HIPO (Hierarchy Input Process Output) 개념
시스템의 분석 및 설계, 문서화 할때 사용되며, **하향식 소프트웨어** 개발을 위한 문서화 도구이다.

### HIPO 특징
1. 체계적인 문서 관리
2. 기호, 도표 등 사용해 보기 쉽고 이해 쉬움
3. **기능과 자료의 의존 관계 동시 표현 가능**
4. 변경, 유지 보수가 용이

### HIPO 차트 종류
> 가총세 (가짜 총이 세개나 있다)

1. *가*시적 도표
2. *총*체적 도표
3. *세*부적 도표

### 소프트웨어 설계 유형
| 설계 유형 | 설명 |
| :--: | :--: |
| 자료구조 설계<br>(Data Structure Design) | 요구 분석 단계에서 생성된 정보 바탕으로 소프트웨어를<br>구현하는데 필요한 자료구조로 변환하는 과정 |
| 아키텍쳐 설계<br>(Architecture Design) | 소프트웨어 시스템의 전체 구조를 기술<br>소프트웨어 구성하는 컴포넌트 간 관계 정의 |
| 인터페이스 설계<br>(Interface Design) | 소프트웨어와 상호 작용하는 컴퓨터 시스템, 사용자 등이<br>어떻게 통신하는지 기술 |
| 프로시저 설계<br>(Procedure Design) | 프로그램 아키텍처의 컴포넌트를 소프트웨어의 컴포넌트의<br>프로시저 서술로 변환하는 과정 |
| *협약에 의한 설계<br>(Design by Contract)* | 1. 선행 조건 : 컴포넌트 오퍼레이션 사용 전 참이 되어야 할 조건<br>2. 결과 조건 : 사용 후 만족되어야 할 조건<br>3. 불변 조건 : 오퍼레이션 실행 동안 항상 만족되어야 할 조건 |

### 코드 설계 종류
|                    종류                    |                                                       설명                                                       |
|:------------------------------------------:|:----------------------------------------------------------------------------------------------------------------:|
|        연상 코드<br>(Mnemonic Code)        |    코드만 보고 연상할 수 있도록 명칭 일부를 약호 형태로 넣어 구성<br>ex. 나라이름 (한국 : KR, 미국 : US, ...)    |
|         블록 코드<br>(Block Code)          | *공통성 있는 것끼리 블록*으로 구분하고, 각 블록 내 일련번호 부여<br>ex. 전화번호 (지역번호 - 국번 - 일련번호 조합) |
|        순차 코드<br>(Sequence Code)        |    일정한 기준에 따라 순서대로 일련번호 부여<br>ex. 중고등 학생들의 반에서 번호 (가나다 순으로 1번, 2번, ...)    |
| **표의 숫자 코드**<br>(Significant Digit Code) |    대상 자료의 *물리적인 수치*인 길이, 넓이, 용량 등 표시한 코드<br>ex. 20 - 10 - 300 (길이 - 넓이 - 용량 조합)    |
|        십진 코드<br>(Decimal Code)         |                              10진수 형태로 표현한 코드<br>ex. 상품 바코드 (880 ...)                              |
| 그룹 분류식 코드<br>(Group Classification) |      대상을 기준에 따라 대분류, 중분류, 소분류로 구분하여 번호 부여<br>ex. 학번 (입학 연도 - 일련번호 조합)      |

### 소프트웨어 설계 원리
1. 상위 설계 - 자료구조 설계, 아키텍쳐 설계, 인터페이스 설계, 프로시저 설계, 협약-설계
2. *하위 설계 - 모듈 설계*

1. 상향식 설계 - 하위 기능들로부터 시작하여 제일 상위 기능에 접근해가는 방식
	   *기존 컴포넌트들을 조합*하여 개발하는 작업
	   상향식 통합 테스트 시 스텁이 아닌 **드라이버**를 작성해야 함
2. 하향식 설계 - 상위 기능에서 시작하여 하위 기능들로 분할해 설계해가는 방식
	시스템 명세가 명확한 경우와 모든 것을 *새로 개발하는 작업*
    인터페이스가 이미 성립되어 있어야지 기능 추가가 쉽다

### 코드 오류 종류
1. 사본 오류 (*Transcription Error*) : *한 자리 잘못 표기* / 필사 오류, 오자 오류
2. 전위 오류 (*Transposition Error*) : *연속된 두 글자가 서로 바뀌어 표기*
3. 생략 오류 (Omission Error) : 한 글자 빼먹고 기술
4. 첨가 오류 (Addition Error) : 한 글자 추가되어 기술
5. 이중 전위 오류 (Double Transposition Error) : 전위 오류가 중복 발생

### 시스템 품질 속성
> 가변성 보사시

1. *가*용성
2. *변*경 용이성
3. *성*능
4. *보*안성
5. *사*용 편의성
6. *시*험 용이성

### 소프트웨어 아키텍처 패턴 유형
|         유형          |                                                                                                    설명                                                                                                    |
|:---------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|      계층화 패턴      |                                    시스템을 계층으로 구분하여 구성하는 패턴<br>각 하위 모듈은 특정 수준 추상화 제공<br>서로 마주보는 두 개의 계층 사이에서만 상호 작용                                     |
| 클라이언트-서버 패턴  |                                   하나의 서버와 다수의 클라이언트로 구성된 패턴<br>사용자가 클라이언트로 서버에 서비스 요청<br>서버는 계속 클라이언트로부터 요청을 대기                                    |
|   **파이프-필터 패턴**    |                    데이터 스트림 생성하고 처리하는 시스템에서 사용 가능한 **단방향 패턴**<br>*서브 시스템이 입력 데이터를 받아 처리하고 <br>결과를 다음 서브 시스템으로 넘겨주는 과정을 반복*<br>필터간 데이터 이동에서 데이터 변환 **오버헤드가 발생**                    |
|      **브로커 패턴**      |                    **분리된 컴포넌트들로 이루어진 분산 시스템에서 사용**되고,<br>이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴<br>ex. Apache, Kafka, JBoss Messaging ...                     |
| 모델-뷰-컨트롤러 패턴 | MVC 패턴. 대화형 애플리케이션을 모델, 뷰, 컨트롤러로 구조화 패턴<br>각 부분이 별도의 컴포넌트로 분리되어 있어서 독립적 개발 작업 가능<br>컴포넌트 분리, 코드의 효율적 재사용 가능, 여러개 뷰에 적합한 패턴 |
| 마스터-슬레이브 패턴  |                                      연산, 통신, 조정을 책임지는 마스터와 <br>제어되고 동기화되는 대상인 슬레이브로 구성되는 패턴<br>*일반적으로 실시간 시스템에 사용*<br>마스터 프로세스는 연산, 통신, 조정을 책임진다<br>슬레이브프로세스는 데이터 수집기능을 수행할 수 **있다 **                                       |

### 소프트웨어 아키텍처 프레임워크 구성요소
|    구성요소     |                                    설명                                    |
|:---------------:|:--------------------------------------------------------------------------:|
| 아키텍처 명세서 |                      아키텍처 기록하기 위한 산출물들                       |
|   이해 관계자   |                   시스템 개발에 관련된 모든 사람과 조직                    |
|     관심사      |            시스템에 대해 이해 관계자들의 서로 다른 의견과 목표             |
|      관점       |               개별 뷰를 개발할 때 토대가 되는 패턴이나 양식                |
|       뷰        |      *서로 관련있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현*       |
|      근거       |                    아키텍처 결정 근거 (회의/보고 결과)                     |
|      목표       | 환경 내 한 명 이상의 이해관계자들이 의도하는 시스템의 목적, 사용, 운영방법 |
|      환경       |          개발, 운영 등 외부 요인 등으로 시스템에 영향을 주는 요인          |
|     시스템      |      각 애플리케이션, 서브 시스템, 시스템의 집합, 제품군 등의 구현체       |

### 소프트웨어 아키텍처 4+1 뷰 구성요소
> 유논프구배 

| 뷰 | 설명 |
| ---- | ---- |
| *유*스케이스 뷰 | 유스케이스 또는 아키텍처를 도출하고 설계하며 <br>*다른 뷰를 검증하는 데 사용*되는 뷰<br>사용자, 설계자, 개발자, 테스트 관점 |
| *논*리 뷰 | 시스템의 *기능적인 요구사항*이 어떻게 제공되는지 설명해주는 뷰<br>설계자, 개발자 관점 |
| *프*로세스 뷰 | 시스템의 *비 기능적인 속성*으로 <br>자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰<br>개발자, 시스템 통합자 관점 |
| *구*현 뷰 | *개발 환경 안에서 정적인 소프트웨어 모듈의 구성*을 보여주는 뷰<br>컴포넌트 구조와 의존성을 보여주고 컴포넌트 관한 부가적인 정보 정의 |
| *배*포 뷰 | 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰<br>물리적 시스템 구성하고 있는 각 부분들의 분산 형태와 설치에 초점 |

### 소프트웨어 아키텍처 비용 평가 모델 종류
> SACAA (사카)

1. SAAM (Software Architecture Analysis Method): *변경 용이성과 기능성*에 집중
2. A*T*AM (Architecture Trade-off Analysis Method): 아키텍처 품질 속성 만족시키는지 
3. C*B*AM (Cost Benefit Analysis Method): 경제적 의사결정 요구를 충족하는 비용 평가 모델
4. ADR (Active Design Review): 소프트웨어 아키텍처 *구성요소 간 응집도를 평가*하는 모델
5. ARID (Active Review for Intermediate Designs): 전체 아키텍쳐가 아닌 *특정 부분에 대한 품질 요소에 집중*하는 비용 평가 모델

## 객체 지향 설계

### 객체 지향 구성 요소
> 클객메 메인속 (앞으로 클 자객을 매매한 인간의 속내)

| 구성요소 |           설명           |
|:--------:|:------------------------:|
|  *클*래스  | 데이터를 추상화하는 단위<br>**하나 이상의 유사 객체들을 묶어 하나의 공통된 특성을 표현**<br>속성은 변수의 형태로, 행위는 메서드 형태로 선언 |
|   *객*체   | 물리적, 추상적으로 자신과 다른 것을 식별 가능한 <br>클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용하고,<br>**일정한 기억장소를 가지고 있다.**                         |
|  *메*서드  | 함수 또는 프로시저에 해당하는 연산 기능<br>객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산<br>*클래스로부터 생성된 객체를 사용하는 방법*<br>*객체에 명령을 내리는 메시지*                         |
|  *메*시지  | *객체에게 어떤 행위를 하도록 지시하는 방법*<br>메시지는 객체에서 객체로 전달됨                         |
| *인*스턴스 | *프로그램에서 클래스를 통해 만든 실제의 실행 객체*<br>프로그램의 실행 단계에서 나타남                         |
|   *속*성   | 한 클래스 내 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의                         |

### 객체 지향 기법
> 캡상다추정관

> 과자제 (과정 추상화 / 자료 추상화 / 제어 추상화)

| 기법 | 설명 |
| :--: | :--: |
| 캡슐화 | **서로 연관된 데이터와 함수를 함께 묶어** 외부와 경계를 만들고 <br>필요한 인터페이스만을 밖으로 드러내는 기법<br>결합도 낮아지고 재사용성 용이, **인터페이스 단순화**, 변경 발생 시 오류 파급 효과 적음<br>객체와 객체간 메세지를 주고 받을 때 각 객체의 세부내용은 알 필요가 없으므로<br>인터페이스가 단순해지고 데이터와 데이터를 처리하는 함수를 하나로 묶는 것 |
| 상속성 | 상위 클래스 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법 |
| 다형성 | 하나의 메시지에 대해 **각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력**<br>상속받은 여러 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질<br>ex. 오버로딩, 오버라이딩 |
| 추상화 | 공통 성질을 추출하여 추상 클래스를 설정하는 기법<br>**과정 추상화, 자료 추상화, 제어 추상화** |
| 정보 은닉 | **코드 내부 데이터와 메서드 숨기고** 공개 인터페이스 통해서만 <br>접근이 가능하도록 하는 코드 보안 기술<br>고려되지 않은 영향인 Side - Effect들을 최소화<br>*모듈 내부 자료구조와 접근 동작들에만 수정을 국한하지 않기 때문에 <br>요구 사항 등 변화에 따른 수정이 많음*<br>모듈 사이 독립성을 유지하는 데 도움을 줌<br>설계에서 은닉되어야 할 기본 정보로 IP 주소같은 물리적 코드, 상세 데이터 구조 존재 |
| 관계성 | 두 개 이상의 엔티티 형에서 데이터를 참조하는 관계를 나타내는 기법<br>*연관화* : is-member-of 관계, 같은 계층 클래스 상호 의존성 보여주는 비계층적 관계<br>*집단화* : **part-whole or is-part-of 관계**, <br>일반화와 달리 **상위 -> 하위 클래스로 상속되지 않음**<br>*분류화* : is-instance-of 관계, 공통 속성에 의해 정의된 객체 구성원들의 인스턴스<br>*일반화* : **is-a 관계**, 클래스들 간의 개념적인 포함관계 상위 특성을 하위가 상속받음<br>*특수화* : is-a 관계, 상위 특성을 상속받으며 하위 클래스에서 나름 고유 특성 갖는 관계 |

### 객체 지향 설계 원칙 (SOLID)
| 원칙 | 설명 |
| :--: | :--: |
| 단일 책임의 <br>원칙 | 하나의 클래스는 하나의 목적을 위해서 생성되며, <br>클래스 제공 모든 서비스는 하나의 책임을 수행하는데 집중되어 있어야 함 |
| 개방 폐쇄 <br>원칙 | 소프트웨어 구성요소 (컴포넌트, 클래스, 모듈, 함수)는<br>*확장에는 열려있고 변경에는 닫혀있어야 한다는 원칙*  |
| 리스코프 <br>*치환* 원칙 | *서브 타입(상속받은 하위 클래스)은 어디서나 자신의 기반 타입(상위 클래스)로<br>교체할 수 있어야 한다는 원칙* |
| 인터페이스 <br>분리 원칙 | 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙<br>클라이언트가 사용하지 않는 인터페이스 때문에 영향 받아서는 안된다는 원칙 |
| 의존성 역전 <br>원칙 | 실제 사용 관계는 바뀌지 않으며, 추상 매개로 메시지 주고받으며 <br>*관계를 최대한 느슨하게 만드는 원칙*  |


### 객체 지향 방법론 종류
> 객동기 (광복 후 우리 사회는 급격한 객(격)동기를 겪었다.)

| 종류 | 만든이 | 설명 |
| :--: | :--: | :--: |
| OOSE<br>(Object Oriented<br>Software Engineering) | <br>야콥슨 | 유스케이스에 의한 접근 방법으로 <br>유스케이스를 만든 모델의 근간으로 활용되는 방법론<br>기능적 요구사항 중심의 시스템 |
| OMT<br>(Object Modeling<br>Technology) | <br>**럼바우** | 그래픽 표기법 이용해 SW 구성 요소 모델링하는 방법론 <br>1. **객체 모델링** : 객체 다이어그램 활용<br>2. **동적 모델링** : **상태 다이어그램** 활용<br>3. **기능 모델링** : **자료 흐름도** (DFD) 활용 |
| OOD<br>(Object Oriented<br>Design) | <br>부치 | 설계 문서화 강조해 다이어그램 중심으로 개발하는 방법론<br>분석과 설계의 분리가 불가능<br>분석하는 데 이용된 객체 모델 설계 시 적용 |
| **Coad Yourdon** |  | **E-R 다이어그램 사용해 객체 행위를 모델링**<br>객체/구조 식별, 주체 정의, 속성 및 관계 정의 등으로 구성 |
| Wirfs-Brock |  | 분석, 설계 간 구분 없고 고객 명세서를 평가해 <br>설계 작업까지 연속적으로 수행하는 분석 방법 |



### 디자인 패턴 종류
> 생구행(생선 구이를 먹으면 행복하다)

> 생빌 프로 팩앱싱 (생더블 날빌 프로브 안뽑고 하길래 팩토리 애(앱)드온해서 시(싱)나게 두들겼다)

> 구 브데 퍼플 프록 컴 어 (9(구) 부대(브데) 퍼플(보라색) 프로(록)토스 컴퓨터 병력이 어디있지?)

##### 생성 패턴
|                 패턴                  |                                                    설명                                                    |
|:-------------------------------------:|:----------------------------------------------------------------------------------------------------------:|
|           **빌더<br>(Builder)**           |                                   복잡한 인스턴스를 조립하여 만드는 구조                                   |
|       **프로토타입**<br>**(Prototype)**       |                   일반 원형 만들어 그것을 복사한 후 **필요한 부분만 수정하여 사용**하는 패턴                   |
|   <br>**팩토리 메서드<br>(Factory Method)**   |    상위 클래스에서 객체 생성 인터페이스를 정의하고,<br>하위 클래스에서 인스턴스를 생성하도록 하는 방식<br>어떤 클래스가 인스턴스화 될 것인지는 서브 클래스가 결정하도록 하는 것<br>**Virtual-Constructor 패턴**     |
| 앱스트랙 팩토리<br>(Abstract Factory) | 구체적 클래스에 의존하지 않고 <br>서로 연관되거나 의존적인 객체들 조합 만드는 인터페이스를 제공하는 패턴 |
|         싱글톤<br>(Singleton)         | 전역 변수를 사용하지 않고 객체 하나만 생성하도록 하며,<br>생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴                                                                                                           |
##### 구조 패턴
|             패턴             | 설명 |
|:----------------------------:|:----:|
|      **브리지<br>(Bridge)**      | 기능 클래스 계층과 구현 클래스 계층을 연결하고,<br>구현부에서 추상 계층을 분리하여 **추상화된 부분과 실제 구현 부분을<br>독립적으로 확장**할 수 있는 패턴     |
|  데코레이터<br>(Decorator)   | 기존 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴<br>기능 확장이 필요할 때 객체 간 결합을 통해 <br>기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용하는 패턴     |
|     퍼사이드<br>(Facade)     | 복잡한 시스템에 대해 단순한 인터페이스를 제공함으로써<br>사용자와 시스템 간 또는 여타 시스템과 결합도를 낮추어 <br>시스템 구조에 대한 파악을 쉽게하는 패턴      |
| 플라이 웨이트<br>(Flyweight) | 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화 하여<br>공유함으로써 메모리를 절약하고, '클래스의 경량화' 목적으로 하는 패턴<br>여러 개의 가상 인스턴스 제공하여 메모리 절감     |
|      프록시<br>(Proxy)       | '실체 객체에 대한 대리 객체'로 실제 객체에 대한 접근 이전에 필요한 행동을 <br>취할 수 있게 만들며, 이 점을 이용해 미리 할당하지 않아도 상관없는 것들을<br>실제 이용 시 할당하게 하여 메모리 용량을 아끼고,<br>실제 객체를 드러나지 않게 하여 정보 은닉 역할도 수행하는 패턴     |
|   컴포지트<br>(Composite)    | 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴<br>복합 객체와 단일 객체를 동일하게 취급     |
|     **어댑터<br>(Adapter)**      | 기존 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 <br>인터페이스를 만드는 패턴으로, 상속을 이용하는 클래스 패턴과 위임을 이용하는<br>인스턴스 패턴 두 가지 형태로 사용되는 패턴     |
##### 행위 패턴
|            패턴            | 설명 |
|:--------------------------:|:----:|
|         미디에이터<br>(Mediator)         | 객체 수 많으면 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법<br>중간에 통제/지시 역할을 하는 중재자를 두고, 모든 것을 요구하여<br>통신 빈도 수를 줄여 객체 지향 목표를 달성하게 해주는 패턴<br>상호 작용의 유연한 변경을 지원     |
|         인터프리터<br>(Interpreter)         | 언어의 다양한 해석, 구체적 구문 분리 후 해석을 맡는 클래스를<br>각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴<br>문법 자체를 캡슐화하여 사용     |
|         이터레이터<br>(Iterator)         | 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는<br>모든 항목에 접근할 방법을 제공하는 패턴     |
|       템플릿 메소드<br>(Template<br>Method)        | 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화 하여<br>전체 일을 수행하는 구조는 바꾸지 않으며 <br>특정 단계에서 수행하는 내역을 바꾸는 패턴<br>**상위 작업 구조 바꾸지 않으면서 서브 클래스로 작업 일부분 수행**     |
|           옵저버<br>(Observer)           | 한 객체 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고<br>자동으로 내용이 갱신되는 방법으로 일대 다 의존성을 가지며<br>상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 패턴<br>**객체 상태 변화에 따라 다른 객체 상태도 연동**     |
|          스테이트<br>(State)          | 객체 상태 자체를 캡슐화하여 클래스화 함으로써 그것을 참조하게 하는 방식으로<br>상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여,<br>변경 시 원시 코드 수정을 최소화 하여 유지 보수 편의성도 가지는 패턴<br>**객체 상태에 따라 행위 내용을 변경**     |
|           **비지터<br>(Visitor)**           | 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도 클래스르 만들어 놓고,<br>해당 클래스 메서드가 각 클래스를 돌며 특정 작업을 수행하도록 만드는 패턴     |
|           커맨드<br>(Command)           | 실행될 기능을 캡슐화 함으로써 주어진 여러 기능을 실행할 수 있는 <br>재사용성 높은 클래스를 설계하는 패턴     |
|         **스트레터지<br>(Strategy)**         | 알고리즘 군을 적용하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로<br>캡슐화한 다음 필요 시 서로 교환해 사용할 수 있게 하는 패턴<br>**행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환**     |
|           모멘토<br>(Momento)           | 클래스 설계 관점에서 객체 정보를 저장할 필요가 있을 때 적용하는 패턴<br>Undo 기능 개발 시 사용하는 패턴     |
| Chain of<br>Responsibility | 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때<br>기능 처리 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라<br>다르게 처리될 수 있도록 연결한 디자인 패턴     |

